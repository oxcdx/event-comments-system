<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ document.title }} - Text Annotator</title>
    <link href="{% if base_path %}{{ base_url_for('static', filename='css/bootstrap.min.css') }}{% else %}{{ url_for('static', filename='css/bootstrap.min.css') }}{% endif %}" rel="stylesheet">
    <link href="{% if base_path %}{{ base_url_for('static', filename='css/document.css') }}{% else %}{{ url_for('static', filename='css/document.css') }}{% endif %}" rel="stylesheet">
    <script src="{% if base_path %}{{ base_url_for('static', filename='js/bootstrap.bundle.min.js') }}{% else %}{{ url_for('static', filename='js/bootstrap.bundle.min.js') }}{% endif %}"></script>
    <script src="{% if base_path %}{{ base_url_for('static', filename='js/socket.io.min.js') }}{% else %}{{ url_for('static', filename='js/socket.io.min.js') }}{% endif %}"></script>
</head>
<body>

  <!-- Toggle button for offcanvas sidebar on smaller screens -->
  <button class="btn btn-primary d-lg-none position-fixed bottom-0 end-0 m-3 z-2" type="button" data-bs-toggle="offcanvas" data-bs-target="#annotationOffcanvas" aria-controls="annotationOffcanvas" id="sidebarToggle">
    <i class="bi bi-chat-dots"></i> Comments
  </button>

  <div class="header logo-container-annotator">
    <div class="">
      <a href="{{ base_path }}/">
        <img
          src="{% if base_path %}{{ base_url_for('static', filename='web-logo.jpg') }}{% else %}{{ url_for('static', filename='web-logo.jpg') }}{% endif %}"
          alt="Logo" class="web-logo">
      </a>
    </div>
    <a href="{{ base_path }}/" class="back-button">‚Üê <span class="d-none d-lg-inline-block">All Lectures</span></a>
  </div>

  <div class="status-indicator" id="status-indicator">Connected</div>

  <!-- Mobile selection tooltip -->
  <div class="selection-tooltip d-lg-none" id="selectionTooltip">
    Add Comment
  </div>

  

  <div class="container">
    <div class="row">

      <div class="document-content col-12 col-lg-7" id="document-content">
        {{ document.content | safe }}
      </div>

      <!-- Desktop sidebar (lg and up) -->
      <div class="col-lg-5  d-none d-lg-block">
        <div class="sidebar">
          <div class="annotation-controls">
            <h3>Annotation Tools</h3>

            <div class="control-group">
              <div class="form-check form-switch">
                <input class="form-check-input" type="checkbox" role="switch" id="highlightsToggle" checked>
                <label class="form-check-label" for="highlightsToggle">
                  Show Highlights
                </label>
              </div>
            </div>

            <div class="control-group">
              <label for="author-name">Your Name:</label>
              <input type="text" id="author-name" value="Anonymous" />
            </div>

            <div class="control-group">
              <label for="comment-text">Comment:</label>
              <textarea id="comment-text" rows="3" placeholder="Add a comment to your selection..."></textarea>
            </div>

            <div class="action-buttons">
              <button class="btn btn-primary" id="add-annotation">Add Annotation</button>
              <button class="btn btn-secondary" id="clear-selection">Clear Selection</button>
            </div>
          </div>

          <div class="annotations-list">
            <h3>Comments</h3>
            <div id="annotations-container">
              <!-- Annotations will be loaded here -->
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Offcanvas sidebar for mobile/tablet (under lg) -->
  <div class="offcanvas offcanvas-end d-lg-none" tabindex="-1" id="annotationOffcanvas" aria-labelledby="annotationOffcanvasLabel">
    <div class="offcanvas-header">
      <h5 class="offcanvas-title" id="annotationOffcanvasLabel">Annotation Tools</h5>
      <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
    </div>
    <div class="offcanvas-body">
      <div class="annotation-controls">
        <div class="control-group">
          <div class="form-check form-switch">
            <input class="form-check-input" type="checkbox" role="switch" id="highlightsToggleMobile" checked>
            <label class="form-check-label" for="highlightsToggleMobile">
              Show Highlights
            </label>
          </div>
        </div>

        <!-- Selected text display for mobile -->
        <div class="control-group d-none" id="selected-text-mobile">
          <label>Selected Text:</label>
          <div class="selected-text-preview" id="selected-text-preview" style="background: #f8f9fa; border: 1px solid #ddd; padding: 8px; border-radius: 4px; font-style: italic; color: #666; max-height: 100px; overflow-y: auto;">
            No text selected
          </div>
        </div>

        <div class="control-group">
          <label for="author-name-mobile">Your Name:</label>
          <input type="text" id="author-name-mobile" value="Anonymous" />
        </div>

        <div class="control-group">
          <label for="comment-text-mobile">Comment:</label>
          <textarea id="comment-text-mobile" rows="3" placeholder="Add a comment to your selection..."></textarea>
        </div>

        <div class="action-buttons">
          <button class="btn btn-primary" id="add-annotation-mobile">Add Annotation</button>
          <button class="btn btn-secondary" id="clear-selection-mobile">Clear Selection</button>
        </div>
      </div>

      <div class="annotations-list">
        <h3>Comments</h3>
        <div id="annotations-container-mobile">
          <!-- Annotations will be loaded here -->
        </div>
      </div>
    </div>
  </div>
    


    <script>
        // Configure Socket.IO to use the correct path for /talks subpath
        const socket = io('{{ base_path }}', {
            path: '{{ base_path }}/socket.io'
        });
        const docId = '{{ document.id }}';
        let currentSelection = null;
        const selectedColor = '#ffff00'; // Always yellow
        let annotations = {{ annotations | tojson }};
        
        // Generate or get user session ID
        let userSessionId = sessionStorage.getItem('userSessionId');
        if (!userSessionId) {
            userSessionId = 'user_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
            sessionStorage.setItem('userSessionId', userSessionId);
        }
        
        // Join the document room
        socket.emit('join_document', {doc_id: docId});
        
        // Socket event handlers
        socket.on('connect', function() {
            document.getElementById('status-indicator').className = 'status-indicator status-connected';
            document.getElementById('status-indicator').textContent = 'Connected';
            document.getElementById('status-indicator').style.display = 'block';
            setTimeout(() => {
                document.getElementById('status-indicator').style.display = 'none';
            }, 3000);
        });
        
        socket.on('disconnect', function() {
            document.getElementById('status-indicator').className = 'status-indicator status-disconnected';
            document.getElementById('status-indicator').textContent = 'Disconnected';
            document.getElementById('status-indicator').style.display = 'block';
        });
        
        socket.on('new_annotation', function(annotation) {
            annotations.push(annotation);
            updateAnnotationsDisplay();
            applyHighlights();
        });
        
        socket.on('annotation_removed', function(data) {
            annotations = annotations.filter(a => a.id !== data.annotation_id);
            updateAnnotationsDisplay();
            applyHighlights();
        });
        
        socket.on('annotation_edited', function(data) {
            const annotation = annotations.find(a => a.id === data.annotation_id);
            if (annotation) {
                annotation.comment = data.new_comment;
                updateAnnotationsDisplay();
                applyHighlights();
            }
        });
        
        socket.on('error', function(data) {
            alert(data.message);
        });
        
        // Text selection handling - use selectionchange for better mobile support
        let selectionTimeout = null;
        let lastTouchEnd = 0;
        
        document.addEventListener('selectionchange', function() {
            // Clear any existing timeout
            if (selectionTimeout) {
                clearTimeout(selectionTimeout);
            }
            
            // Set a longer timeout to allow users to adjust selection on mobile
            selectionTimeout = setTimeout(handleTextSelection, 1200); // 1.2 seconds delay
        });
        
        // Better touch handling for mobile devices
        document.getElementById('document-content').addEventListener('touchend', function(e) {
            lastTouchEnd = Date.now();
            // Give much more time for touch selection to stabilize and allow adjustment
            setTimeout(() => {
                // Only process if this was the last touch event and enough time has passed
                if (Date.now() - lastTouchEnd >= 800) {
                    handleTextSelection();
                }
            }, 1000); // 1 second delay after touch ends
        });
        
        // Keep mouseup for desktop with shorter delay
        document.getElementById('document-content').addEventListener('mouseup', function() {
            setTimeout(handleTextSelection, 100);
        });
        
        // Clear temporary highlight when clicking outside the document content
        document.addEventListener('click', function(event) {
            if (!document.getElementById('document-content').contains(event.target) && 
                !document.getElementById('comment-text').contains(event.target) &&
                !document.getElementById('add-annotation').contains(event.target) &&
                !document.getElementById('selectionTooltip').contains(event.target)) {
                removeTemporaryHighlight();
                hideMobileTooltip();
                currentSelection = null;
            }
        });
        
        // Clear temporary highlight when pressing Escape
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                removeTemporaryHighlight();
                window.getSelection().removeAllRanges();
                hideMobileTooltip();
                currentSelection = null;
            }
        });
        
        function handleTextSelection() {
            const selection = window.getSelection();
            console.log('Selection changed, range count:', selection.rangeCount); // Debug
            
            if (selection.rangeCount > 0 && !selection.isCollapsed) {
                const range = selection.getRangeAt(0);
                
                // Check if selection is within document content
                const documentContent = document.getElementById('document-content');
                if (!documentContent.contains(range.commonAncestorContainer) && 
                    range.commonAncestorContainer !== documentContent) {
                    console.log('Selection not in document content'); // Debug
                    return;
                }
                
                // Expand selection to word boundaries
                const expandedRange = expandToWordBoundaries(range);
                if (expandedRange) {
                    // Update the selection to the expanded range
                    selection.removeAllRanges();
                    selection.addRange(expandedRange);
                    
                    const selectedText = expandedRange.toString().trim();
                    console.log('Expanded selected text:', selectedText); // Debug
                    
                    if (selectedText.length > 0) {
                        currentSelection = {
                            text: selectedText,
                            range: expandedRange.cloneRange(),
                            startOffset: getTextOffset(expandedRange.startContainer, expandedRange.startOffset),
                            endOffset: getTextOffset(expandedRange.endContainer, expandedRange.endOffset)
                        };
                        
                        console.log('Current selection:', currentSelection); // Debug
                        
                        // Add temporary highlight to the selected text
                        addTemporaryHighlight(currentSelection.range);
                        
                        // Update mobile selected text preview
                        updateSelectedTextPreview(selectedText);
                        
                        // Show mobile tooltip instead of auto-opening offcanvas
                        if (window.innerWidth < 992) {
                            showMobileTooltip(currentSelection.range);
                        } else {
                            // Focus the appropriate comment textarea on desktop
                            const activeElements = getActiveElements();
                            activeElements.commentText.focus();
                        }
                    }
                }
            } else {
                console.log('No selection or collapsed selection'); // Debug
                // Clear temporary highlight when no selection
                removeTemporaryHighlight();
                clearSelectedTextPreview();
                hideMobileTooltip();
                currentSelection = null;
            }
        }
        
        function updateSelectedTextPreview(selectedText) {
            if (window.innerWidth < 992) { // Only for mobile
                const previewElement = document.getElementById('selected-text-preview');
                const containerElement = document.getElementById('selected-text-mobile');
                
                if (selectedText && selectedText.trim()) {
                    previewElement.textContent = selectedText;
                    containerElement.classList.remove('d-none');
                } else {
                    clearSelectedTextPreview();
                }
            }
        }
        
        function expandToWordBoundaries(range) {
            try {
                const startContainer = range.startContainer;
                const endContainer = range.endContainer;
                const startOffset = range.startOffset;
                const endOffset = range.endOffset;
                
                // Create a new range to work with
                const expandedRange = range.cloneRange();
                
                // Expand start to word boundary
                if (startContainer.nodeType === Node.TEXT_NODE) {
                    const startText = startContainer.textContent;
                    let newStartOffset = startOffset;
                    
                    // Move backwards to find word start (or beginning of text)
                    while (newStartOffset > 0 && /\w/.test(startText.charAt(newStartOffset - 1))) {
                        newStartOffset--;
                    }
                    
                    expandedRange.setStart(startContainer, newStartOffset);
                }
                
                // Expand end to word boundary
                if (endContainer.nodeType === Node.TEXT_NODE) {
                    const endText = endContainer.textContent;
                    let newEndOffset = endOffset;
                    
                    // Move forwards to find word end (or end of text)
                    while (newEndOffset < endText.length && /\w/.test(endText.charAt(newEndOffset))) {
                        newEndOffset++;
                    }
                    
                    expandedRange.setEnd(endContainer, newEndOffset);
                }
                
                return expandedRange;
            } catch (error) {
                console.warn('Error expanding to word boundaries:', error);
                return range; // Return original range if expansion fails
            }
        }
        
        function clearSelectedTextPreview() {
            const previewElement = document.getElementById('selected-text-preview');
            const containerElement = document.getElementById('selected-text-mobile');
            
            previewElement.textContent = 'No text selected';
            containerElement.classList.add('d-none');
        }
        
        function showMobileTooltip(range) {
            const tooltip = document.getElementById('selectionTooltip');
            if (!tooltip) return;
            
            // Get the bounding rect of the selection
            const rects = range.getClientRects();
            if (rects.length === 0) return;
            
            // Use the last rect (end of selection) for positioning
            const lastRect = rects[rects.length - 1];
            const documentContent = document.getElementById('document-content');
            const contentRect = documentContent.getBoundingClientRect();
            
            // Position tooltip above the end of selection, relative to document
            let tooltipX = lastRect.left + (lastRect.width / 2); // Center on selection
            let tooltipY = lastRect.top - 50; // 50px above the selection
            
            // Ensure tooltip stays within viewport bounds
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const tooltipWidth = 120; // Approximate tooltip width
            const tooltipHeight = 40; // Approximate tooltip height
            
            // Adjust X position
            if (tooltipX - tooltipWidth / 2 < 10) {
                tooltipX = tooltipWidth / 2 + 10;
            } else if (tooltipX + tooltipWidth / 2 > viewportWidth - 10) {
                tooltipX = viewportWidth - tooltipWidth / 2 - 10;
            }
            
            // Adjust Y position - if too close to top, show below selection
            if (tooltipY < 60) {
                tooltipY = lastRect.bottom + 10;
            }
            
            tooltip.style.left = tooltipX + 'px';
            tooltip.style.top = (tooltipY + window.scrollY) + 'px';
            tooltip.classList.add('show');
            
            console.log('Showing tooltip at:', tooltipX, tooltipY); // Debug
            
            // Add click handler if not already added
            if (!tooltip.hasAttribute('data-click-handler')) {
                tooltip.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    hideMobileTooltip();
                    removeTemporaryHighlight();
                    openMobileOffcanvas();
                });
                tooltip.setAttribute('data-click-handler', 'true');
            }
        }
        
        function hideMobileTooltip() {
            const tooltip = document.getElementById('selectionTooltip');
            if (tooltip) {
                tooltip.classList.remove('show');
            }
        }
        
        function getTextOffset(node, offset) {
            const documentContent = document.getElementById('document-content');
            const walker = document.createTreeWalker(
                documentContent,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            
            let textOffset = 0;
            let currentNode;
            
            while (currentNode = walker.nextNode()) {
                if (currentNode === node) {
                    return textOffset + offset;
                }
                textOffset += currentNode.textContent.length;
            }
            
            return textOffset;
        }
        
        // Sidebar button handlers
        document.getElementById('add-annotation').addEventListener('click', function() {
            if (currentSelection) {
                addAnnotation();
            } else {
                alert('Please select some text first to add an annotation.');
            }
        });
        
        document.getElementById('add-annotation-mobile').addEventListener('click', function() {
            if (currentSelection) {
                addAnnotation();
            } else {
                alert('Please select some text first to add an annotation.');
            }
        });
        
        document.getElementById('clear-selection').addEventListener('click', function() {
            window.getSelection().removeAllRanges();
            removeTemporaryHighlight();
            clearSelectedTextPreview();
            hideMobileTooltip();
            currentSelection = null;
        });
        
        document.getElementById('clear-selection-mobile').addEventListener('click', function() {
            window.getSelection().removeAllRanges();
            removeTemporaryHighlight();
            clearSelectedTextPreview();
            hideMobileTooltip();
            currentSelection = null;
        });
        
        // Highlights toggle handlers
        document.getElementById('highlightsToggle').addEventListener('change', function() {
            toggleHighlights(this.checked);
            // Sync with mobile toggle
            document.getElementById('highlightsToggleMobile').checked = this.checked;
        });
        
        document.getElementById('highlightsToggleMobile').addEventListener('change', function() {
            toggleHighlights(this.checked);
            // Sync with desktop toggle
            document.getElementById('highlightsToggle').checked = this.checked;
        });
        
        function toggleHighlights(show) {
            const highlights = document.querySelectorAll('.annotation-highlight');
            highlights.forEach(highlight => {
                highlight.style.display = show ? 'block' : 'none';
            });
        }
        
        // Function to open offcanvas on mobile
        function openMobileOffcanvas() {
            if (window.innerWidth < 992) { // Bootstrap lg breakpoint
                const offcanvas = new bootstrap.Offcanvas(document.getElementById('annotationOffcanvas'));
                offcanvas.show();
            }
        }
        
        // Function to get appropriate input elements based on screen size
        function getActiveElements() {
            if (window.innerWidth < 992) {
                return {
                    authorName: document.getElementById('author-name-mobile'),
                    commentText: document.getElementById('comment-text-mobile'),
                    annotationsContainer: document.getElementById('annotations-container-mobile')
                };
            } else {
                return {
                    authorName: document.getElementById('author-name'),
                    commentText: document.getElementById('comment-text'),
                    annotationsContainer: document.getElementById('annotations-container')
                };
            }
        }
        
        // Sync values between desktop and mobile inputs
        function syncInputValues() {
            const desktopAuthor = document.getElementById('author-name').value;
            const mobileAuthor = document.getElementById('author-name-mobile').value;
            const desktopComment = document.getElementById('comment-text').value;
            const mobileComment = document.getElementById('comment-text-mobile').value;
            
            // Sync author names
            if (desktopAuthor !== mobileAuthor) {
                if (window.innerWidth < 992) {
                    document.getElementById('author-name').value = mobileAuthor;
                } else {
                    document.getElementById('author-name-mobile').value = desktopAuthor;
                }
            }
            
            // Sync comments
            if (desktopComment !== mobileComment) {
                if (window.innerWidth < 992) {
                    document.getElementById('comment-text').value = mobileComment;
                } else {
                    document.getElementById('comment-text-mobile').value = desktopComment;
                }
            }
        }
        
        // Add input event listeners for syncing
        document.getElementById('author-name').addEventListener('input', function() {
            document.getElementById('author-name-mobile').value = this.value;
        });
        
        document.getElementById('author-name-mobile').addEventListener('input', function() {
            document.getElementById('author-name').value = this.value;
        });
        
        document.getElementById('comment-text').addEventListener('input', function() {
            document.getElementById('comment-text-mobile').value = this.value;
        });
        
        document.getElementById('comment-text-mobile').addEventListener('input', function() {
            document.getElementById('comment-text').value = this.value;
        });
        
        function addTemporaryHighlight(range) {
            // Remove any existing temporary highlight first
            removeTemporaryHighlight();
            
            console.log('Adding temporary highlight...'); // Debug
            
            const rects = range.getClientRects();
            const containerRect = document.getElementById('document-content').getBoundingClientRect();
            
            console.log('Container rect:', containerRect); // Debug
            console.log('Rects found:', rects.length); // Debug
            
            // Create temporary highlight overlays for each rectangle (handles line breaks)
            for (let i = 0; i < rects.length; i++) {
                const rect = rects[i];
                const highlight = document.createElement('div');
                
                // Make it very visible for testing
                highlight.style.position = 'absolute';
                highlight.style.backgroundColor = '#ff0000'; // Red for testing
                highlight.style.opacity = '0.8'; // High opacity for testing
                highlight.style.zIndex = '999'; // Very high z-index
                highlight.style.pointerEvents = 'none';
                highlight.style.border = '3px solid #0000ff'; // Blue border
                highlight.style.left = (rect.left - containerRect.left) + 'px';
                highlight.style.top = (rect.top - containerRect.top) + 'px';
                highlight.style.width = rect.width + 'px';
                highlight.style.height = rect.height + 'px';
                highlight.className = 'temporary-highlight';
                highlight.dataset.temporary = 'true';
                
                console.log('Created highlight with rect:', rect); // Debug
                console.log('Positioned at:', {
                    left: highlight.style.left,
                    top: highlight.style.top,
                    width: highlight.style.width,
                    height: highlight.style.height
                }); // Debug
                
                document.getElementById('document-content').appendChild(highlight);
            }
            
            console.log('Temporary highlights in DOM:', document.querySelectorAll('.temporary-highlight').length); // Debug
        }
        
        function removeTemporaryHighlight() {
            // Remove all temporary highlights
            document.querySelectorAll('.temporary-highlight').forEach(el => el.remove());
        }
        
        function addAnnotation() {
            if (!currentSelection) {
                alert('Please select some text first to add an annotation.');
                return;
            }
            
            const activeElements = getActiveElements();
            const comment = activeElements.commentText.value.trim();
            const author = activeElements.authorName.value.trim();
            
            if (!author) {
                alert('Please enter your name.');
                activeElements.authorName.focus();
                return;
            }
            
            const annotation = {
                doc_id: docId,
                start_offset: currentSelection.startOffset,
                end_offset: currentSelection.endOffset,
                selected_text: currentSelection.text,
                comment: comment,
                author: author,
                color: selectedColor,
                session_id: userSessionId
            };
            
            socket.emit('add_annotation', annotation);
            
            // Clear the form, selection, and temporary highlight
            document.getElementById('comment-text').value = '';
            document.getElementById('comment-text-mobile').value = '';
            window.getSelection().removeAllRanges();
            removeTemporaryHighlight();
            clearSelectedTextPreview();
            currentSelection = null;
        }
        
        function updateAnnotationsDisplay() {
            const container = document.getElementById('annotations-container');
            const mobileContainer = document.getElementById('annotations-container-mobile');
            const annotationHTML = generateAnnotationsHTML();
            
            container.innerHTML = annotationHTML;
            mobileContainer.innerHTML = annotationHTML;
        }
        
        function generateAnnotationsHTML() {
            let html = '';
            
            annotations.forEach(annotation => {
                const isOwnAnnotation = annotation.session_id === userSessionId;
                const commentHtml = annotation.comment ? 
                    `<div class="annotation-comment" id="comment-display-${annotation.id}">${escapeHtml(annotation.comment)}</div>
                     <textarea class="annotation-edit" id="comment-edit-${annotation.id}" style="display: none; width: 100%; margin-bottom: 8px;">${escapeHtml(annotation.comment)}</textarea>` : 
                    '<div class="annotation-comment">No comment</div>';
                
                const actionsHtml = isOwnAnnotation ? 
                    `<div class="annotation-actions">
                        <button class="edit-annotation" onclick="editAnnotation('${annotation.id}')" style="background: #667eea; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 0.8em; margin-right: 5px;">Edit</button>
                        <button class="save-annotation" onclick="saveAnnotation('${annotation.id}')" style="background: #48bb78; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 0.8em; margin-right: 5px; display: none;">Save</button>
                        <button class="cancel-annotation" onclick="cancelEdit('${annotation.id}')" style="background: #a0aec0; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 0.8em; margin-right: 5px; display: none;">Cancel</button>
                        <button class="remove-annotation" onclick="removeAnnotation('${annotation.id}')" style="background: #e53e3e; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 0.8em;">Delete</button>
                     </div>` : '';
                
                const itemHTML = `
                    <div class="annotation-item" style="background: #f8f9fa; border-left: 4px solid ${annotation.color}; padding: 15px; margin-bottom: 10px; position: relative;" data-annotation-id="${annotation.id}">
                        <div class="accordion mb-2" id="accordion-${annotation.id}">
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="heading-${annotation.id}">
                                    <button class="accordion-button collapsed p-1" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-${annotation.id}" aria-expanded="false" aria-controls="collapse-${annotation.id}" >
                                        Quoted Text
                                    </button>
                                </h2>
                                <div id="collapse-${annotation.id}" class="accordion-collapse collapse" aria-labelledby="heading-${annotation.id}" data-bs-parent="#accordion-${annotation.id}">
                                    <div class="accordion-body" style="padding: 8px 12px; font-size: 0.9em; font-style: italic; color: #666;">
                                        "${escapeHtml(annotation.selected_text)}"
                                    </div>
                                </div>
                            </div>
                        </div>
                        ${commentHtml}
                        <div class="annotation-meta">
                            <span>by ${escapeHtml(annotation.author)}</span>
                            ${actionsHtml}
                        </div>
                    </div>
                `;
                
                html += itemHTML;
            });
            
            return html;
        }
        
        function highlightAnnotation(annotationId) {
            const highlights = document.querySelectorAll(`[data-annotation-id="${annotationId}"]`);
            highlights.forEach(highlight => {
                if (highlight.classList.contains('annotation-highlight')) {
                    highlight.classList.add('highlighted');
                }
            });
        }
        
        function unhighlightAnnotation(annotationId) {
            const highlights = document.querySelectorAll(`[data-annotation-id="${annotationId}"]`);
            highlights.forEach(highlight => {
                if (highlight.classList.contains('annotation-highlight')) {
                    highlight.classList.remove('highlighted');
                }
            });
        }
        
        function removeAnnotation(annotationId) {
            socket.emit('remove_annotation', {
                annotation_id: annotationId,
                doc_id: docId,
                session_id: userSessionId
            });
        }
        
        function editAnnotation(annotationId) {
            const displayElement = document.getElementById(`comment-display-${annotationId}`);
            const editElement = document.getElementById(`comment-edit-${annotationId}`);
            const editButton = document.querySelector(`[onclick="editAnnotation('${annotationId}')"]`);
            const saveButton = document.querySelector(`[onclick="saveAnnotation('${annotationId}')"]`);
            const cancelButton = document.querySelector(`[onclick="cancelEdit('${annotationId}')"]`);
            
            // Hide display, show edit
            displayElement.style.display = 'none';
            editElement.style.display = 'block';
            editButton.style.display = 'none';
            saveButton.style.display = 'inline-block';
            cancelButton.style.display = 'inline-block';
            
            // Focus the textarea
            editElement.focus();
        }
        
        function saveAnnotation(annotationId) {
            const editElement = document.getElementById(`comment-edit-${annotationId}`);
            const newComment = editElement.value.trim();
            
            socket.emit('edit_annotation', {
                annotation_id: annotationId,
                doc_id: docId,
                new_comment: newComment,
                session_id: userSessionId
            });
        }
        
        function cancelEdit(annotationId) {
            const annotation = annotations.find(a => a.id === annotationId);
            const displayElement = document.getElementById(`comment-display-${annotationId}`);
            const editElement = document.getElementById(`comment-edit-${annotationId}`);
            const editButton = document.querySelector(`[onclick="editAnnotation('${annotationId}')"]`);
            const saveButton = document.querySelector(`[onclick="saveAnnotation('${annotationId}')"]`);
            const cancelButton = document.querySelector(`[onclick="cancelEdit('${annotationId}')"]`);
            
            // Restore original value
            editElement.value = annotation.comment || '';
            
            // Show display, hide edit
            displayElement.style.display = 'block';
            editElement.style.display = 'none';
            editButton.style.display = 'inline-block';
            saveButton.style.display = 'none';
            cancelButton.style.display = 'none';
        }
        
        function applyHighlights() {
            // Remove existing permanent highlights (but keep temporary ones)
            document.querySelectorAll('.annotation-highlight:not(.temporary-highlight)').forEach(el => el.remove());
            
            const documentContent = document.getElementById('document-content');
            
            // If no annotations, just return
            if (annotations.length === 0) return;
            
            annotations.forEach((annotation, index) => {
                try {
                    const range = createRangeFromTextOffset(annotation.start_offset, annotation.end_offset);
                    if (range) {
                        createAnnotationOverlay(range, annotation, index);
                    }
                } catch (error) {
                    console.warn('Failed to create overlay for annotation:', annotation, error);
                }
            });
        }
        
        function createRangeFromTextOffset(startOffset, endOffset) {
            const documentContent = document.getElementById('document-content');
            const textContent = documentContent.textContent;
            
            // Validate offsets
            if (startOffset < 0 || endOffset > textContent.length || startOffset >= endOffset) {
                return null;
            }
            
            const walker = document.createTreeWalker(
                documentContent,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            
            let currentOffset = 0;
            let startNode = null, startPos = 0;
            let endNode = null, endPos = 0;
            let node;
            
            while (node = walker.nextNode()) {
                const nodeLength = node.textContent.length;
                const nodeEnd = currentOffset + nodeLength;
                
                if (startNode === null && startOffset >= currentOffset && startOffset <= nodeEnd) {
                    startNode = node;
                    startPos = startOffset - currentOffset;
                }
                
                if (endNode === null && endOffset >= currentOffset && endOffset <= nodeEnd) {
                    endNode = node;
                    endPos = endOffset - currentOffset;
                    break;
                }
                
                currentOffset = nodeEnd;
            }
            
            if (startNode && endNode) {
                const range = document.createRange();
                try {
                    range.setStart(startNode, startPos);
                    range.setEnd(endNode, endPos);
                    return range;
                } catch (error) {
                    console.warn('Error creating range:', error);
                    return null;
                }
            }
            
            return null;
        }
        
        function createAnnotationOverlay(range, annotation, index) {
            const rects = range.getClientRects();
            const containerRect = document.getElementById('document-content').getBoundingClientRect();
            
            // Create highlight overlays for each rectangle (handles line breaks)
            for (let i = 0; i < rects.length; i++) {
                const rect = rects[i];
                const highlight = document.createElement('div');
                highlight.className = 'annotation-highlight';
                highlight.style.backgroundColor = annotation.color;
                highlight.style.left = (rect.left - containerRect.left) + 'px';
                highlight.style.top = (rect.top - containerRect.top) + 'px';
                highlight.style.width = rect.width + 'px';
                highlight.style.height = rect.height + 'px';
                highlight.title = `${annotation.author}: ${annotation.comment || 'Highlight'}`;
                highlight.dataset.annotationId = annotation.id;
                
                document.getElementById('document-content').appendChild(highlight);
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Initialize the page
        updateAnnotationsDisplay();
        applyHighlights();
        
        // Reapply highlights when window is resized
        window.addEventListener('resize', function() {
            setTimeout(applyHighlights, 100);
        });
    </script>
</body>
</html>
